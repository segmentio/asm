// Code generated by command: go run equal_fold_asm.go -pkg ascii -out ../ascii/equal_fold_amd64.s -stubs ../ascii/equal_fold_amd64.go. DO NOT EDIT.

#include "textflag.h"

// func EqualFoldString(a string, b string) bool
// Requires: AVX, AVX2, SSE4.1
TEXT ·EqualFoldString(SB), NOSPLIT, $0-33
	MOVQ         a_base+0(FP), CX
	MOVQ         a_len+8(FP), DX
	MOVQ         b_base+16(FP), BX
	CMPQ         DX, b_len+24(FP)
	JNE          done
	XORQ         AX, AX
	MOVQ         $0xdfdfdfdfdfdfdfdf, SI
	BTL          $0x08, github·com∕segmentio∕asm∕cpu·X86+0(SB)
	JCC          eq8
	PINSRQ       $0x00, SI, X8
	VPBROADCASTQ X8, Y8
	CMPQ         DX, $0x80
	JNB          eq128

eq64:
	CMPQ      DX, $0x40
	JB        eq32
	VPAND     (CX)(AX*1), Y8, Y0
	VPAND     (BX)(AX*1), Y8, Y1
	VPCMPEQB  Y1, Y0, Y0
	VPAND     32(CX)(AX*1), Y8, Y2
	VPAND     32(BX)(AX*1), Y8, Y3
	VPCMPEQB  Y3, Y2, Y2
	VPAND     Y2, Y0, Y0
	VPMOVMSKB Y0, DI
	ADDQ      $0x40, AX
	SUBQ      $0x40, DX
	CMPL      DI, $0xffffffff
	JNE       done

eq32:
	CMPQ    DX, $0x20
	JB      eq16
	VMOVDQU (CX)(AX*1), Y0
	VPXOR   (BX)(AX*1), Y0, Y0
	ADDQ    $0x20, AX
	SUBQ    $0x20, DX
	VPTEST  Y8, Y0
	JNE     done

eq16:
	CMPQ    DX, $0x10
	JB      eq8
	VMOVDQU (CX)(AX*1), X0
	VPXOR   (BX)(AX*1), X0, X0
	ADDQ    $0x10, AX
	SUBQ    $0x10, DX
	VPTEST  X8, X0
	JNE     done

eq8:
	CMPQ  DX, $0x08
	JB    eq4
	MOVQ  (CX)(AX*1), DI
	XORQ  (BX)(AX*1), DI
	ADDQ  $0x08, AX
	SUBQ  $0x08, DX
	TESTQ SI, DI
	JNE   done
	JMP   eq8

eq4:
	CMPQ  DX, $0x04
	JB    eq3
	MOVL  (CX)(AX*1), SI
	XORL  (BX)(AX*1), SI
	ADDQ  $0x04, AX
	SUBQ  $0x04, DX
	TESTL $0xdfdfdfdf, SI
	JNE   done

eq3:
	CMPQ    DX, $0x03
	JB      eq2
	MOVWLZX (CX)(AX*1), DX
	MOVBLZX 2(CX)(AX*1), CX
	SHLL    $0x10, CX
	ORL     DX, CX
	MOVWLZX (BX)(AX*1), DX
	MOVBLZX 2(BX)(AX*1), AX
	SHLL    $0x10, AX
	ORL     DX, AX
	XORL    CX, AX
	TESTL   $0x00dfdfdf, AX
	JMP     done

eq2:
	CMPQ  DX, $0x02
	JB    eq1
	MOVW  (CX)(AX*1), CX
	XORW  (BX)(AX*1), CX
	TESTW $0xdfdf, CX
	JMP   done

eq1:
	CMPQ  DX, $0x00
	JE    done
	MOVB  (CX)(AX*1), CL
	XORB  (BX)(AX*1), CL
	TESTB $0xdf, CL

done:
	SETEQ ret+32(FP)
	RET

eq128:
	VPAND     (CX)(AX*1), Y8, Y0
	VPAND     (BX)(AX*1), Y8, Y1
	VPCMPEQB  Y1, Y0, Y0
	VPAND     32(CX)(AX*1), Y8, Y2
	VPAND     32(BX)(AX*1), Y8, Y3
	VPCMPEQB  Y3, Y2, Y2
	VPAND     64(CX)(AX*1), Y8, Y4
	VPAND     64(BX)(AX*1), Y8, Y5
	VPCMPEQB  Y5, Y4, Y4
	VPAND     96(CX)(AX*1), Y8, Y6
	VPAND     96(BX)(AX*1), Y8, Y7
	VPCMPEQB  Y7, Y6, Y6
	VPAND     Y2, Y0, Y0
	VPAND     Y6, Y4, Y4
	VPAND     Y4, Y0, Y0
	VPMOVMSKB Y0, DI
	ADDQ      $0x80, AX
	SUBQ      $0x80, DX
	CMPL      DI, $0xffffffff
	JNE       done
	CMPQ      DX, $0x80
	JB        eq64
	JMP       eq128
